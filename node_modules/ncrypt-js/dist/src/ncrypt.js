"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = __importStar(require("crypto"));
/**
 * @class Ncrypt
 * @type {Ncrypt.<object>}
 */
class Ncrypt {
    /**
     * object constructor
     * @param {secret.<string>} secret
     */
    constructor(secret) {
        /**
         * algorithm used for encoding message
         */
        this.algorithm = 'aes-256-cbc';
        /**
         * ecoding for encrypted stirng
         */
        this.enc = (process.env.NCRYPT_ENC) || 'hex';
        /**
         * crypto random initial vector generated from core node {crypto} module
         */
        this.initialVector = crypto.randomBytes(16);
        /**
         * crypto random key generated from core node {crypto} module
         * {note}: please read the value for KEY from your app's environment
         */
        this.key = crypto.scryptSync(process.env.KEY || 'please provide a KEY in your .env file or config', 'salt', 32);
        /**
         * convert all entered text to decimal equivalent character codes
         * @param {text.<string>} text to be converted
         * @return {Array.<number>} array of character codes
         */
        this.convertTextToDecimal = (text) => {
            return text.split('').map((value) => value.charCodeAt(0));
        };
        /**
         * encode provided secret on decimal character codes
         * @param {charCode.<number, number[]>} charCodes
         * @returns {*.<number>} decimal string
         */
        this.applySecretToCharacters = (charCodes) => {
            return this.convertTextToDecimal(this.secret)
                .reduce((firstValue, secondValue) => (firstValue ^ secondValue), charCodes);
        };
        /**
         * convert character bytes to hexadecimal equivalent
         * @param {number.<number>} number
         * @returns {*.<string>} hexadecimal string
         */
        this.convertByteToHexadecimal = (number) => {
            return ('0' + Number(number).toString(16)).substr(-2);
        };
        /**
         * intermediate data encoder function
         * @param {string.<any>} text
         * @param secret
         * @returns {string} encrypted or cipher text
         */
        this.encode = (text) => {
            let cipher = crypto.createCipheriv(this.algorithm, Buffer.from(this.key), this.initialVector);
            let encrypted = cipher.update(text);
            encrypted = Buffer.concat([encrypted, cipher.final()]);
            return `${this.initialVector.toString(this.enc)}.${encrypted.toString(this.enc)}`;
        };
        /**
         * intermediate data decoder function
         * @param {string.<any>} text
         * @returns {string.<string>} decrypted data
         */
        this.decode = (text) => {
            if (typeof text !== 'string') {
                throw new TypeError('argument must be a string, or a string-like object');
            }
            const iv = text.split('.')[0];
            const encryptedData = text.split('.')[1];
            let _iv = Buffer.from(iv, this.enc);
            let encryptedText = Buffer.from(encryptedData, this.enc);
            let decipher = crypto.createDecipheriv(this.algorithm, Buffer.from(this.key), _iv);
            let decrypted = decipher.update(encryptedText);
            decrypted = Buffer.concat([decrypted, decipher.final()]);
            return decrypted.toString();
        };
        this.secret = secret;
        // bind public instance methods
        this.encrypt = this.encrypt.bind(this);
        this.decrypt = this.decrypt.bind(this);
    }
    /**
     * generate random strings
     * @example
     *
     * var fs = require('fs');
     * var ncrypt = require('ncrypt-js');
     *
     * console.log(ncrypt.randomString(8, 'base64')); // g3lzZ48TW6w==
     *
     * @param {size.<number>} size
     * @param {enc.<string>} enc
     * @returns {*.<string>} string
     */
    static randomString(size, enc = 'base64') {
        return crypto.randomBytes(size || 64).toString(enc);
    }
    /**
     * data to be encrypted
     * @param {data.<stirng>} data
     * @returns {*.<string>} encrypted text
     */
    encrypt(data) {
        /**
         * this does the actual processing return a string
         * resulting from charCode conversion, salting and
         * hexadecimal mapping
         */
        try {
            const encodedMessage = JSON.stringify(data).split('')
                .map(this.convertTextToDecimal)
                .map(this.applySecretToCharacters)
                .map(this.convertByteToHexadecimal)
                .join('');
            return this.encode(encodedMessage);
        }
        catch (e) {
            throw new Error('invalid data was entered, enter data of type object, number, string or boolean to be encrypted.' + e);
        }
    }
    /**
     * text be decrypted
     * @param {text.<stirng>} text
     * @returns {*.<string>} decrypted data
     */
    decrypt(text) {
        const encodeData = this.decode(text);
        const data = (encodeData).match(/.{1,2}/g)
            .map((hex) => parseInt(hex, 16))
            .map(this.applySecretToCharacters)
            .map((charCode) => String.fromCharCode(charCode))
            .join('');
        return JSON.parse(data);
    }
}
exports.default = Ncrypt;
